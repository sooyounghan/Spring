-----
### 테스트 - 데이터베이스 분리
-----
1. 로컬에서 사용하는 애플리케이션 서버와 테스트에서 같은 데이터베이스를 사용하므로 테스트에서 문제 발생
2. 따라서, 테스트를 다른 환경과 철저하게 분리
3. 가장 간단한 방법은 테스트 전용 데이터베이스를 별도 운영
   - 즉, H2 데이터베이스를 용도에 따라 2가지로 구분
   - jdbc:h2:tcp://localhost/~/test : local에서 접근하는 서버 전용 데이터베이스
   - jdbc:h2:tcp://localhost/~/testcase : test 케이스에서 사용하는 전용 데이터베이스
4. 데이터베이스 파일 생성 방법
   - 데이터베이스 서버를 종료하고 다시 실행
     + 사용자명 : sa
     + JDBC URL 입력 : jdbc:h2:~/testcase (최초 한번)
     + ~/testcase.mv.db 파일 생성 확인
     + 이후부터는 jdbc:h2:tcp://localhost/~/testcase 이렇게 접속

-----
### 테이블 생성하기
-----
1. testcase 데이터베이스에도 item 테이블 생성
2. sql/schema.sql 파일 참고
```java
DROP TABLE IF EXISTS item CASCADE; 
CREATE TABLE item
(
    id        BIGINT GENERATED BY DEFAULT AS IDENTITY, 
    item_name VARCHAR(10),
    price INTEGER, 
    quantity INTEGER,
    PRIMARY KEY (id) 
);
```
3. 접속 정보 변경
   - main에 있는 application.properties는 그대로 유지하고, test에 있는 application.properties만 변경
   - main - applciation.properties
```properties
spring.profiles.active=local
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.username=sa
```
   - test - application.properties
```properties
spring.profiles.active=test
spring.datasource.url=jdbc:h2:tcp://localhost/~/testcase
spring.datasource.username=sa
```

4. 접속 정보가 jdbc:h2:tcp://localhost/~/test에서 jdbc:h2:tcp://localhost/~/testcase로 변경
5. 테스트 실행
   - findItems()만 단독으로 테스트하면, 처음에는 실행에 성공하나 다시 실행하면 테스트에 실패
   - 테스트를 2번째 실행할 때 실패하는 이유는 testcase 데이터베이스에 접속해서 item 테이블의 데이터를 확인하면 알 수 있음
   - 처음 테스틑 실행할 때 저장한 데이터가 계속 남아있으므로 두번째 테스트에 영향을 준 것
   - 이 문제는 save()와 같은 다른 테스트를 먼저 실행하고 나서 findItems()를 실행할 때도 나타남
   - 다른 테스트에서 이미 데이터를 추가했기 때문임. 즉, 결과적으로 테스트 데이터가 오염된 것
   - 이 문제를 해결하려면 각 테스트가 끝날 때 마다 해당 테스트에 추가한 데이터를 삭제해야 함
   - 그래야 다른 테스트에 영향을 주지 않음

6. 테스트 원칙
   - 💡 테스트는 다른 테스트와 격리되어야 함
   - 💡 테스트는 반복해서 실행할 수 있어야 함

7. 테스트가 끝날 때 마다 DELETE SQL을 사용해도 되지만, 궁극적인 해결책이 아님
8. 만약, 테스트 과정에서 데이터를 이미 추가했는데, 테스트가 실행되는 도중 예외가 발생하거나 애플리케이션이 종료되어 테스트 종료 시점에 DELETE SQL을 호출하지 못하면 결국 데이터가 남게됨

