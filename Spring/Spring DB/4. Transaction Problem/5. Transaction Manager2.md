-----
### 트랜잭션 매니저 전체 동작 흐름
-----
1. 트랜잭션 매니저1 -트랜잭션 시작
<div align="center">
<img src="https://github.com/sooyounghan/Spring/assets/34672301/a660a924-9833-4a2a-bb26-466317d4361f">
</div>

  - 클라이언트의 요청에 따라 서비스 로직 실행
  - 서비스 계층에서 transactionManager.getTransaction()을 호출해 트랜잭션 실행
  - 트랜잭션을 시작하려면, 먼저 데이터베이스 커넥션이 필요
  - 트랜잭션 매니저는 내부에서 데이터소스를 사용해 커넥션 생성
  - 커넥션을 수동 커밋 모드로 변경해 실제 데이터베이스 트랜잭션 시작
  - 커넥션을 트랜잭션 동기화 매니저에 보관
  - 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관하므로 멀티 쓰레드 환경에 안전하게 커넥션 보관 가능

2. 트랜잭션 매니저2- 로직 실행
<div align="center">
<img src="https://github.com/sooyounghan/Spring/assets/34672301/ae4562b9-01df-4309-84d7-114961ab4382">
</div>

  - 서비스는 비즈니스 로직을 실행하면서 레포지토리의 메서드들을 호출
  - 이 때, 커넥션을 파라미터로 전달하지 않음
  - 레포지토리 메서드들은 트랜잭션이 시작된 커넥션이 필요하므로, 레포지토리는 DataSourceUtils.getConnection()을 사용해 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용
  - 이 과정을 통해 자연스럽게 같은 커넥션을 사용하고, 트랜잭션도 유지
  - 획득한 커넥션을 사용해 SQL을 데이터베이스에 전달해서 사용

3. 트랜잭션 매니저3 - 트랜잭션 종료
<div align="center">
<img src="https://github.com/sooyounghan/Spring/assets/34672301/04db7ebe-a86f-4fa3-a2c9-85fcb32f8d0e">
</div>

  - 비즈니스 로직이 끝나고 트랜잭션 종료. 트랜잭션은 커밋하거나 롤백하면 종료
  - 트랜잭션을 종료하려면 동기화된 커넥션이 필요
  - 트랜잭션 동기화 매니저를 통해 동기화된 커넥션 획득
  - 획득한 커넥션을 통해 데이터베이스에 트랜잭션을 커밋하거나 롤백
  - 전체 리소스를 정리
    + 💡 트랜잭션 동기화 매니저를 정리 (쓰레드 로컬은 사용 후 꼭 정리)
    + 💡 conn.setAutoCommit(true)로 되돌림 (커넥션 풀 고려)
    + con.close()를 호출해서 커넥션 종료 (커넥션 풀을 사용하면 커넥션 풀에 보관)

-----
### 정리
-----
1. 트랜잭션 추상화로 인해 서비스 코드는 JDBC 기술에 의존하지 않음
   + 이후 JDBC에서 JPA로 변경해도 서비스 코드 그대로 유지 가능
   + 기술 변경시 주입 관계만 DataSourceTransactionManager에서 JpaTransactionManager로 변경
   + java.sql.SQLException은 추후 해결

2. 트랜잭션 동기화 매니저 덕분에 커넥션을 파라미터로 넘기지 않아도 됨
     
