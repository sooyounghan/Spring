-----
### 양방향 매핑
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/4a14b849-176a-4849-a31e-d0ea2ea6b273">
</div>

1. Member Entity : 단방향과 동일
```java
package hellojpa;

import jakarta.persistence.*;

import java.util.Date;

@Entity
public class Member {

    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;

    ...
}
```

2. Team Entity : 컬렉션 추가
```java
package hellojpa;

import jakarta.persistence.*;

import java.util.ArrayList;
import java.util.List;

@Entity
public class Team {
    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;

    private String name;

    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();

    ...
}
```
  - Team은 하나(One) → Member는 다수(Many) : Team Entity 기준 @OneToMany
  - Member의 어떠한 필드에 Mapping을 시킬 것인지 속성 추가 : mappedBy = "team"

3. 양방향 매핑 (반대 방향으로 객체 그래프 탐색)
```java
package hellojpa;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.EntityTransaction;
import jakarta.persistence.Persistence;

import java.util.List;

public class JpaMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
        EntityManager em = emf.createEntityManager();

        EntityTransaction tx = em.getTransaction(); // 트랜잭션
        tx.begin(); // 트랜잭션 시작


        try {
            // 저장
            Team team = new Team();
            team.setName("TeamA");
            em.persist(team);

            Member member = new Member();
            member.setUsername("member1");
            member.setTeam(team);
            em.persist(member);


            em.flush(); // DB로 INSERT SQL 쿼리 전송
            em.clear(); // 1차 캐시 내용 삭제

            // 조회
            Member findMember = em.find(Member.class, member.getId());

            // 양방향 연결관계 (역방향 조회)
            List<Member> members = findMember.getTeam().getMembers();
            for (Member m : members) {
                System.out.println("m = " + m.getUsername());
            }

            tx.commit();
        } catch (Exception e) {
            tx.rollback();
        } finally {
            em.close();
        }
        emf.close();
    }
}

```
  - 실행 로그
```
Hibernate: 
    create table Team (
        TEAM_ID bigint not null,
        name varchar(255),
        primary key (TEAM_ID)
    )

Hibernate: 
    alter table if exists Member 
       add constraint FKl7wsny760hjy6x19kqnduasbm 
       foreign key (TEAM_ID) 
       references Team

Hibernate: 
    select
        next value for Team_SEQ
Hibernate: 
    select
        next value for Member_SEQ

Hibernate: 
    /* insert for
        hellojpa.Team */insert 
    into
        Team (name, TEAM_ID) 
    values
        (?, ?)

Hibernate: 
    /* insert for
        hellojpa.Member */insert 
    into
        Member (TEAM_ID, USERNAME, MEMBER_ID) 
    values
        (?, ?, ?)

Hibernate: 
    select
        m1_0.MEMBER_ID,
        t1_0.TEAM_ID,
        t1_0.name,
        m1_0.USERNAME 
    from
        Member m1_0 
    left join
        Team t1_0 
            on t1_0.TEAM_ID=m1_0.TEAM_ID 
    where
        m1_0.MEMBER_ID=?

Hibernate: 
    select
        m1_0.TEAM_ID,
        m1_0.MEMBER_ID,
        m1_0.USERNAME 
    from
        Member m1_0 
    where
        m1_0.TEAM_ID=?

m = member1
```

-----
### 연관관계 주인과 mappedBy
-----
1. 💡 객체와 테이블 간에 연관 관계를 맺는 차이
  - 객체 연관 관계 = 2개
    + 회원 → 팀 연관관계 : 1개 (단방향)
    + 팀 → 회원 연관관계 : 1개 (단방향)
  - 테이블 연관 관계 = 1개
    + 회원 ↔ 팀의 연관관계 : 1개 (양방향)

<div align="center">
<img src="https://github.com/user-attachments/assets/bc4bdec6-9f51-4837-b76b-0b599f52325e">
</div>

2. 💡 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개
  - 💡 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 함
  - A → B (a.getB())
```java
class A {
    B b;
}
```

  - B → A (b.getA())
```java
class B {
    A a;
}
```

3. 테이블의 양방향 연관관계
   - 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리
   - MEMBER.TEAM_ID 외래 키 하나로 양방향 연관관계를 가짐 (양쪽으로 조인 가능)

```sql
SELECT *
FROM MEMBER M
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
```
```sql
SELECT *
FROM TEAM T
JOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID
```

  - 💡 둘 중 하나로 외래 키를 관리해야 함
<div align="center">
<img src="https://github.com/user-attachments/assets/3aae1a73-19df-4679-8917-e8a1da28cb04">
</div>

  - 즉, Member의 team으로 연관관계 매핑을 통해 외래 키를 관리할 것인지, Team의 members으로 연관관계 매핑을 통해 외래 키를 관리할 것인지 고민 필요

4. 💡 연관관계의 주인 (Owner) - 양방향 매핑 규칙
   - 객체의 두 관계 중 하나를 연관관계의 주인으로 지정
   - 💡 연관관계의 주인만이 외래 키를 관리 (등록, 수정)
   - 💡 주인이 아닌 쪽은 읽기만 가능
   - 💡 주인은 mappedBy 속성을 사용하지 않음
   - 💡 주인이 아니라면 mappedBy 속성으로 주인 지정
   - 💡💡💡 외래 키가 있는 곳을 주인으로 지정 (외래키가 있는 곳 : 다(N), 외래키가 없는 곳 : 1)
     + 💡 즉, N쪽이 무조건 연관관계의 주인 (@ManyToOne : 연관관계 주인) 
     + 💡 즉, 1쪽은 연관관계의 주인이 아님 (@OneToMany : 연관관계의 주인이 아님) - mappedBy
     + 💡 여기서는 Member.team이 연관관계의 주인
<div align="center">
<img src="https://github.com/user-attachments/assets/b6f2f0fb-8eef-4c39-a258-5fb3ab7aae39">
</div>
