-----
### 핵심 기능과 부가 기능을 분리
-----
1. 부가 기능 도입의 문제점들을 해결하기 위해, 부가 기능을 핵심 기능에서 분리하고 한 곳에서 관리하도록 함
2. 그리고, 해당 부가 기능을 어디에 적용할 지 선택하는 기능도 만듬
3. 💡 Aspect(에스펙트) : 부가 기능과 부가 기능을 어디에 적용할지 선택하는 기능을 합해서 하나의 모듈로 만든 것
  - 💡 즉, 부가 기능과, 해당 부가 기능을 어디에 적용할지 정의한 것
  - 예를 들어, 로그 출력 기능을 모든 컨트롤러에 적용하는 것

4. 즉, @Aspect이며, 스프링이 제공하는 어드바이저도 어드바이스(부가 기능)과 포인트 컷(적용 대상)을 가지고 있으므로, 개념상 하나의 Aspect
5.  'Aspect'는 '관점'이라는 뜻이데, 💡💡💡 이는 이름 그대로 애플리케이션을 바라보는 관점을 하나의 기능에서 횡단 관심사(Cross-Cutting Concerns) 관점을 달리 보는 것
   - 💡 이처럼, 에스펙트를 사용한 프로그래밍 방식 : 관점 지향 프로그래밍 (AOP, Aspect-Oriented Programming)
   - 💡💡💡 참고로, AOP는 OOP를 대체하기 위함이 아닌 횡단 관심사를 깔끔하게 처리하기 어려운 OOP의 부족한 부분을 보조하는 목적으로 개발

<div align="center">
<img src="https://github.com/user-attachments/assets/50cf2689-41f9-4d50-9a99-98ecc9a81304">
<img src="https://github.com/user-attachments/assets/c66c052c-f392-4a9c-8094-cbdc0d8b8224">
</div>

-----
### AspectJ 프레임워크
-----
1. AOP의 대표적인 구현
2. https://www.eclipse.org/aspectj/
3. 스프링도 AOP를 지원하지만, 대부분 AspectJ의 문법을 차용하고, AspectJ가 제공하는 기능의 일부만 제공
4. 자바 프로그래밍 언어에 대한 완벽한 관점 지향 확장
5. 횡단 관심사의 깔끔한 모듈화
   - 오류 검사 및 처리
   - 동기화
   - 성능 최적화 (캐싱)
   - 모니터링 및 로깅

-----
### AOP 적용 방식
-----
1. AOP를 사용하면 핵심 기능과 부가 기능이 코드 상 완전히 분리되어서 관리
2. 그렇다면, AOP를 사용할 때 부가 기능 로직은 어떤 방식은 실제 로직에 추가?
   - 컴파일 시점
   - 클래스 로딩 시점
   - 런타임 시점 (프록시)

3. 컴파일 시점 (컴파일 타임 - 위빙(Weaving))
<div align="center">
<img src="https://github.com/user-attachments/assets/49137504-1b1f-485c-89ce-3df6a0410156">
</div>

  - .java 소스 코드를 컴파일러를 사용해서 .class를 만드는 시점에 부가 기능 로직 추가 가능
  - 이 때는, AspectJ가 제공하는 특별한 컴파일러 사용
  - 컴파일 된 .class를 디컴파일 해보면, 에스펙트 관련 호출 코드가 들어감
  - 즉, 핵심 기능이 있는 컴파일된 코드 내 부가 기능을 호출하는 코드 존재
  - AspectJ 컴파일러는 Aspect를 확인해 해당 클래스가 적용 대상인지 먼저 확인하고, 적용 대상이면 부가 기능 로직 적용
  - 💡 위빙(Weaving) : 원본 로직에 부가 기능 로직이 추가되는 것
    + 옷 감을 짜다, 직조하다 = 에스펙트와 실제 코드를 연결해서 붙이는 것
  - 단점 : 컴파일 시점에 부가 기능을 적용하려면 특별한 컴파일러도 필요하고 복잡

4. 클래스 로딩 시점(로드 타임 - 위빙)
<div align="center">
<img src="https://github.com/user-attachments/assets/d4d27016-9937-4511-8bf6-4fde6bc54551">
</div>

  - 자바를 실행하면 자바 언어는 .class 파일을 JVM 내부 클래스 로더에 보관
  - 이 때, 중간에서 .class 파일을 조작한 다음 JVM에 올릴 수 있음
  - 자바 언어는 .class를 JVM에 저장하기 전에 조작할 수 있는 기능 제공 (Java Instrumentation)
  - 참고로, 수 많은 모니터링 툴들이 이 방식 사용
  - 이 시점에 에스펙트를 적용하는 것을 '로드 타임 위빙'
  - 단점 : 로드 타임 위빙은 자바를 실행할 때 특별한 옵션 (java -javaagent)를 통해 클래스 로더 조작기를 지정해야 함
     + 따라서, 번거롭고 운영하기 어려움

5. 런타임 시점 (런타임 - 위빙)
<div align="center">
<img src="https://github.com/user-attachments/assets/a6a948dc-66e9-4716-8fcb-41686c3f7f15">
</div>

  - 런타임 시점은 컴파일도 다 끝나고, 클래스 로더에 클래스도 다 올라가서 이미 자바가 실행되고 난 다음을 말함
  - 자바의 메인(main) 메서드가 이미 실행된 다음을 의미
  - 따라서, 자바 언어가 제공하는 범위 안에서 부가 기능을 적용해야 함
  - 스프링과 같은 컨테이너의 도움을 받고, 프록시와 DI, 빈 후처리기 같은 개념들을 총 동원해야 함
  - 이렇게 하면 최종적으로, 프록시를 통해 스프링 빈에 부가 기능 적용 가능
  - 즉, 현재까지 사용했던 프록시 방식의 AOP
  - 💡 프록시를 사용하므로 AOP 기능에 일부 제약이 있으나, 특별한 컴파일러나, 자바를 실행할 때 복잡한 옵션과 클래스 로더 조작기를 설정하지 않아도 됨 (스프링만 있으면 가능)

6. 부가 기능이 적용되는 차이
   - 컴파일 시점
     + 실제 대상 코드에 에스펙트를 통한 부가 기능 호출 코드가 포함
     + AspectJ를 직접 사용해야 함

   - 클래스 로딩 시점
     + 실제 대상 코드에 에스펙트를 통한 부가 기능 호출 코드가 포함
     + AspectJ를 직접 사용해야 함

   - 런타임 시점
     + 💡 실제 대상 코드는 그대로 유지
     + 💡 대신에 프록시를 통해 부가 기능이 적용
     + 💡 따라서, 항상 프록시를 통해야 부가 기능 사용 가능
     + 스프링 AOP의 방식

7. AOP 적용 위치
   - AOP는 메서드 실행 위치 뿐만 아니라 다양한 위치에 적용 가능
   - 💡 적용 가능 지점(조인 포인트) : 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행
     + 💡 조인 포인트(Join Point) : AOP를 적용할 수 있는 지점

   - AspectJ를 사용해 컴파일 시점과 클래스 로딩 시점에 적용하는 AOP는 바이트 코드를 실제 조작하므로 해당 기능을 모든 지점에 다 적용 가능
   - 💡 프록시 방식을 사용하는 스프링 AOP는 메서드 실행 지점에만 AOP 적용 가능
     + 💡 프록시는 메서드 오버라이딩 개념으로 동작
     + 따라서, 생성자나 static 메서드, 필드 값 접근에는 프록시 개념이 적용될 수 없음
     + 💡 프록시를 사용하는 스프링의 AOP 조인 포인트는 메서드 실행으로 제한
   - 💡 프록시 방식을 사용하는 스프링 AOP는 스프링 컨테이너가 관리할 수 있는 스프링 빈에만 AOP 적용 가능

8. 💡 스프링은 AspectJ 문법을 차용하고 프록시 방식의 AOP를 적용하는 것이지, AspectJ를 직접 사용하는 것이 아님
9. 💡 스프링이 제공하는 AOP는 프록시를 사용
    - 💡 따라서, 프록시를 통해 메서드를 실행하는 시점에만 AOP가 적용
    - AspectJ를 사용하면, 더 복잡하고 다양한 기능 사용 가능
    - AspectJ를 사용하려면, 자바 관련 설정(특별한 컴파일러, AspectJ 전용 문법, 자바 실행 옵션)도 복잡
    - 반면에 AOP는 별도의 추가 자바 설정 없이 스프링만 있으면 편리하게 AOP 사용 가능
    - 또한, 실무에서 스프링이 제공하는 AOP 기능만 사용해도 대부분 문제 해결 가능하므로, 스프링 AOP가 제공하는 기능에 집중
