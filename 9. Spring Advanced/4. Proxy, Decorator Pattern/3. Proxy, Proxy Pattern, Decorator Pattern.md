-----
### 프록시 (Proxy)
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/f5aa8997-c10f-4c2b-ae9b-e4ec3870d96d">
</div>

1. 클라이언트(Client)와 서버(Server)라고 하면 보통 서버 컴퓨터를 생각
2. 사실 클라이언트와 서버의 개념은 넓게 사용
   - 클라이언트는 의뢰인이라는 뜻
   - 서버는 '서비스나 상품을 제공하는 사람이나 물건'을 뜻함
3. 💡 따라서 클라이언트와 서버의 기본 개념을 정의하면, 클라이언트는 서버에 필요한 것을 요청하고, 서버는 클라이언트의 요청을 처리

4. 이 개념을 컴퓨터 네트워크에 도입하면, 클라이언트는 웹 브라우저가 되고, 요청을 처리하는 서버는 웹 서버가 됨
5. 이 개념을 객체에 도입하면, 요청하는 객체는 클라이언트, 요청을 처리하는 객체는 서버
6. 직접 호출과 간접 호출
  - 직접 호출 : 클라이언트와 서버 개념에서 일반적으로 클라이언트가 서버를 직접 호출하고, 처리 결과를 직접 받음
<div align="center">
<img src="https://github.com/user-attachments/assets/431cd3e3-9dad-4150-9525-70c207eb51ce">
</div>

  - 💡 간접 호출 : 클라이언트가 요청한 결과를 서버에 직접 요청하는 것이 아니라 어떤 대리자가 대신 간접적으로 서버에 요청 가능
    + 예를 들어, 직접 마트에서 장을 볼 수 있지만, 누군가가 대신 장을 봐달라고 부탁할 수 있음
    + 이 대리자를 '프록시(Prxy)'
<div align="center">
<img src="https://github.com/user-attachments/assets/c13b935e-6605-4e70-b617-70649d20806e">
</div>

  - 예시) 직접 호출과 다르게 간접 호출을 하면 대리자가 중간에서 여러 가지 일을 할 수 있음
    + A. 엄마에게 라면을 사달라고 부탁했는데, 엄마가 그 라면은 이미 집에 있다고 할 수 있음. 그러면 기대보다 더 빨리 라면을 먹을 수 있음 (💡 접근 제어, 캐싱)
    + B. 아버지께서 자동차 주유를 부탁했는데, 아버지가 주유 뿐만 아니라 세차까지 하고 옴. 클라이언트가 기대한 것 외에 세차라는 부가 기능 획득 (💡 부가 기능 추가)
    + C. 대리자가 또 다른 대리자를 부를 수 있음. 예를 들어, 동생에게 라면을 사달라고 부탁했는데, 동생은 또 다른 누군가에게 라면을 사달라고 다시 요청 가능. 중요한 점은 클라이언트는 대리자를 통해 요청했기 때문에, 그 이후 과정은 모름
      * 즉, 동생을 통해서 라면이 나에게 도착하기만 하면 됨 (💡 프록시 체인)
<div align="center">
<img src="https://github.com/user-attachments/assets/d4dfa192-da64-4ff7-b05d-336425d25d50">
</div>

7. 대체 기능
<div align="center">
<img src="https://github.com/user-attachments/assets/da0352e0-b8b5-47a0-b5b3-658b7d73583d">
</div>

  - 객체에서 프록시가 되려면, 클라이언트는 서버에게 요청한 것인지, 프록시에게 요청을 한 것인지 조차 몰라야 함
  - 💡 즉, 서버와 프록시는 같은 인터페이스를 사용해야 함
  - 💡 그리고, 클라이언트가 사용하는 서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 변경하지 않고 동작할 수 있어야 함

8. 💡 서버와 프록시가 같은 인터페이스 사용
- 💡 클래스 의존관계를 보면 클라이언트는 서버 인터페이스(ServerInterface)에만 의존
- 그리고 서버와 프록시가 같은 인터페이스를 사용
- 따라서, DI를 사용해 대체 가능

9. 런타임 객체 의존 관계
<div align="center">
<img src="https://github.com/user-attachments/assets/8d4b4617-0032-4869-9777-b0a20939fc2c">
<img src="https://github.com/user-attachments/assets/b0d80da3-2d33-4400-b222-02ac2c4eb1bc">
</div>

  - 이번에는 런타임 객체 의존 관계 보면, 런타임(애플리케이션 실행 시점)에 클라이언트 객체에 DI를 사용해서 Client → Server에서 Client → Proxy로 객체 의존 관계를 변경해도 클라이언트 코드를 전혀 변경하지 않아도 됨
  - 클라이언트 입장에서 변경 사실조차 모름
  - DI를 사용하면 클라이언트 코드의 변경 없이 유연하게 프록시 주입 가능

-----
### 프록시의 주요 기능
-----
1. 접근 제어
   + 권한에 따른 접근 차단
   + 캐싱
   + 지연 로딩

2. 부가 기능 추가
   + 원래 서버가 제공하는 기능에 더해 부가 기능 수행
   + 예) 요청 값이나, 응답 값을 중간에 변형
   + 예) 실행 시간을 측정해 추가 로그를 남김

3. 프록시 객체가 중간에 있으면, 크게 접근 제어와 부가 기능 추가를 수행 가능

-----
### GOF 디자인 패턴
-----
1. 💡 둘 다 프록시를 사용하는 방법이지만, GOF 디자인 패턴에서는 이 둘을 의도(Intent)에 따라 프록시 패턴과 데코레이터 패턴으로 구분
   - 💡 프록시 패턴 : 접근 제어가 목적 (= 프록시를 의미하는 것이 아님)
   - 💡 데코레이터 패턴 : 새로운 기능 추가가 목적

2. 💡 둘 다 프록시를 사용하지만, 의도가 다르다는 점이 핵심
3. 💡 용어가 프록시 패턴이라고 해서, 이 패턴만 프록시를 사용하는 것이 아님. 데코레이터 패턴도 프록시 사용
4. 프록시라는 개념은 클라이언트-서버라는 큰 개념안에서 자연스럽게 발생 가능
   - 프록시는 객체 안에서의 개념도 있고, 웹 서버에서의 프록시도 존재
   - 객체안에서 객체로 구현되어있는가, 웹 서버로 구현되어 있는가 처럼 규모의 차이가 있을 뿐 근본적인 역할은 같음
